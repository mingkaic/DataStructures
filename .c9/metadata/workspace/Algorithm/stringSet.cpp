{"changed":true,"filter":false,"title":"stringSet.cpp","tooltip":"/Algorithm/stringSet.cpp","value":"//\n//  stringSet.cpp\n//  Array\n//\n//  Created by Ming Kai Chen on 2014-05-09.\n//  Copyright (c) 2014 Ming Kai Chen. All rights reserved.\n//\n\n#include \"StringSet.h\"\n\n// Default constructor\nStringSet::StringSet(): _curSize(0), _maxSize(4)\n{\n    _data = new string*[_maxSize];\n}\n\n// Copy constructor\nStringSet::StringSet(const StringSet &obj):\n    _curSize(obj._curSize),\n    _maxSize(obj._maxSize)\n{\n    _data = new string*[_maxSize];\n    \n    // make deep copy\n    for (int i = 0; i < _curSize; i++) {\n        _data[i] = new string(*(obj._data[i]));\n    }\n}\n\n// Destructor\nStringSet::~StringSet()\n{\n    for (int i = 0; i < _curSize; i++) {\n        delete _data[i];\n    }\n    \n    delete[] _data;\n}\n\n// Checks and expands the array to make it dynamic\nvoid StringSet::dynamicSize()\n{\n    if (_curSize < _maxSize) return;\n    \n    // Doubles the size\n    _maxSize *= 2;\n    string** newData = new string*[_maxSize];\n    \n    // shallow copy is fine\n    for (int i = 0; i < _curSize; i++) {\n        newData[i] = _data[i];\n    }\n    \n    delete[] _data;\n    _data = newData;\n}\n\n// Return true if the inserting obj is unique in the arr, else false\nbool StringSet::insert(string str)\n{\n    // the condition is true only if the obj is in the data array\n    if (find(str) != -1) return false;\n\n    dynamicSize();\n    \n    _data[_curSize] = new string(str);\n    \n    _curSize++;\n    \n    return true;\n}\n\n// Return true if str is removed, else false\nbool StringSet::remove(string str)\n{\n    int index = find(str);\n\n    if (index == -1) return false;\n    \n    // Element at _curSize doesn't belong, _data[_curSize-1] would pick up garabage.\n    // Better to ignore it.\n    delete _data[index];\n    \n    for (; index < _curSize - 1; index++) {\n        _data[index] = _data[index+1];\n    }\n    \n    _curSize--;\n    return true;\n}\n\n// Return -1 if str not found, else index of str\n// Since _data is unsorted, use linear search\nint StringSet::find(string str) const\n{\n    for (int i = 0; i < _curSize; i++) {\n        // comparison issues???\n        if (*_data[i] == str) {\n            return i;\n        }\n    }\n    \n    return -1;\n}\n\n// Returns _curSize\nint StringSet::size() const\n{\n    return _curSize;\n}\n\n/* \n * NOTE: set manipulation methods all return object by value,\n * as such local objects are made in stack. \n */\n\n// Returns StringSet object that holds the union of the _data arrays in this and obj\nStringSet StringSet::unions(const StringSet &obj) const\n{\n    // new Set is identical to obj Set\n    StringSet jointSet(obj);\n    \n    for (int i = 0; i < _curSize; i++) {\n        //insert automatically filters out repeated entries\n        jointSet.insert(*_data[i]);\n    }\n    \n    return jointSet;\n}\n\n// Returns object that holds the intersection of _data arrays in this & obj\nStringSet StringSet::intersection(const StringSet &obj) const\n{\n    // new Set is empty!\n    StringSet jointSet;\n    \n    for (int i = 0; i < _curSize; i++) {\n        // only insert if the _data is found in both this and obj Sets\n        if (obj.find(*_data[i]) != -1) {\n            jointSet.insert(*_data[i]);\n        }\n    }\n    \n    return jointSet;\n}\n\n// Returns object that holds the difference of _data arrays in this & obj\n// NOTE: Even Though difference = union - intersection. performing two functions would increase the leading coefficient of the running time by two\nStringSet StringSet::difference(const StringSet &obj) const\n{\n    // new Set is empty\n    StringSet jointSet;\n    \n    for (int i = 0; i < _curSize; i++) {\n        // insert elements unique to this\n        if (obj.find(*_data[i]) == -1) {\n            jointSet.insert(*_data[i]);\n        }\n    }\n    \n    return jointSet;\n}\n\nvoid StringSet::print() const\n{\n    for (int i = 0; i < _curSize; i++) {\n        cout << *_data[i] << endl;\n    }\n}","undoManager":{"mark":6,"position":4,"stack":[[{"start":{"row":2,"column":4},"end":{"row":2,"column":18},"action":"remove","lines":["cmpt225Assign1"],"id":2},{"start":{"row":2,"column":4},"end":{"row":2,"column":5},"action":"insert","lines":["A"]}],[{"start":{"row":2,"column":5},"end":{"row":2,"column":6},"action":"insert","lines":["r"],"id":3}],[{"start":{"row":2,"column":6},"end":{"row":2,"column":7},"action":"insert","lines":["r"],"id":4}],[{"start":{"row":2,"column":7},"end":{"row":2,"column":8},"action":"insert","lines":["a"],"id":5}],[{"start":{"row":2,"column":8},"end":{"row":2,"column":9},"action":"insert","lines":["y"],"id":6}],[{"start":{"row":5,"column":21},"end":{"row":5,"column":22},"action":"remove","lines":["4"],"id":14},{"start":{"row":5,"column":21},"end":{"row":5,"column":22},"action":"insert","lines":["5"]}],[{"start":{"row":4,"column":41},"end":{"row":4,"column":42},"action":"insert","lines":["0"],"id":13}],[{"start":{"row":4,"column":40},"end":{"row":4,"column":41},"action":"insert","lines":["2"],"id":12}],[{"start":{"row":4,"column":39},"end":{"row":4,"column":40},"action":"insert","lines":["-"],"id":11}],[{"start":{"row":4,"column":38},"end":{"row":4,"column":39},"action":"insert","lines":["2"],"id":10}],[{"start":{"row":4,"column":37},"end":{"row":4,"column":38},"action":"insert","lines":["1"],"id":9}],[{"start":{"row":4,"column":36},"end":{"row":4,"column":37},"action":"insert","lines":["-"],"id":8}],[{"start":{"row":4,"column":35},"end":{"row":4,"column":43},"action":"remove","lines":["4-05-09."],"id":7},{"start":{"row":4,"column":35},"end":{"row":4,"column":36},"action":"insert","lines":["5"]}]]},"ace":{"folds":[],"scrolltop":1020,"scrollleft":0,"selection":{"start":{"row":9,"column":0},"end":{"row":9,"column":0},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":6,"state":"start","mode":"ace/mode/c_cpp"}},"timestamp":1453324575273}